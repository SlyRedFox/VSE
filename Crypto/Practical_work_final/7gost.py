# Задание 7 на экзамене: основное, ниже конкретное
# 7.	Дано сообщение M. Подписать данное сообщение по алгоритму ГОСТ Р 34.10-2012 (параметры эллиптической кривой будут
# даны в задании). В качестве хэш-функции взять сложение блоков сообщения длины n (в двоичном представлении) по модулю  .
# + https://my.mts-link.ru/19684723/2134589447/record-new/954249942

# Примечания!
# 1. Для списка binary_numbers  нужно будет внести значения в соответствии с количеством битов, на которые его делим,
# в рассмотренном примере данные делятся в соответствии со значением 5 бит
# 2. Чем меньше k, тем лучше, задаём 3

print('Взять в качестве сообщения свои инициалы. Подписать сообщение по алгоритму ГОСТ Р 34.10-2012. Параметры '
      'эллиптической кривой даны ниже. В качестве хэш-функции взять сложение блоков сообщения длины n по модулю 2**n')


p: int = 103
a_el: int = 6
b_el: int = 4
P = [3, 7]
q = 59
print(f'Входные данные:  {p}  {a_el}  {b_el}  {P}  {q}')

M = 'EOO'
print(f'Сообщение M = {M}')

print('\nШаг 1. Вычисляем хеш-код сообщения по ф-ле M = h(M)')
print('Представляем сообщение в виде двоичной последовательности и склаываем блоки друг с другом')

print(f'Находим значение n - размер блока, на который делим. Это log2({q}), результат: n = ')
from math import log2
n: int = int(log2(q))
print(n)

print(f'Берём инициалы, разбиваем их на блоки размером {n} бит и складываем друг с другом')

print('Инициалы в ASCII:')
ascii_list = [ord(char) for char in M]
print(ascii_list)

print('Переводим в двоичное представление')
bin_ascii: list = []
for key in ascii_list:
      print(f'{bin(key)[2:]}')
      bin_ascii.append(bin(key)[2:])
print(bin_ascii)

print('Получаем наше M')
M_all_string = ''.join(bin_ascii)
print(M_all_string)




print(f'Разделяем на кусочки по {n} битов, сюда вносим наши данные. Тут базовый пример для 5 бит, нули в начале не нужны')
binary_numbers = ['1000', '01011', '00011', '10100', '01110']
# Функция для перевода двоичного числа в десятичное
def binary_to_decimal(binary_num):
    return int(binary_num, 2)
# Суммирование десятичных значений двоичных чисел
decimal_sum = sum(binary_to_decimal(num) for num in binary_numbers)

# Перевод обратно в двоичную систему
result_binary = bin(decimal_sum)[2:]

print("Результат для числа h(M):", result_binary)

h_int = int(result_binary, 2)
h_bin = bin(h_int % 2**n)[2:]
print(f"Остаток от деления 00111000 на (mod 2**{n}):", h_bin)
print(f'h(M) = {h_bin}')

print('\nШаг 2. 	Вычислить целое число a, двоичным представлением которого является вектор ¯h, и определить e=a (mod q). '
      'Если e=0, то определить e=1.')
a = int(h_bin, 2)
print(f'В десятичном представлении {h_bin} = a = {a}')

e = a % q
print(f'Находим e = a mod {q}, e =  {e}')


print('\nШаг 3 	Сгенерировать случайное целое число k, удовлетворяющее неравенству 0<k<q.')
k = 7
print('ЭТО ЧИСЛО ДАЁТ МНОЖЕСТВО ВЫЧИСЛЕНИЙ ПО ЭЛЛИПТИСЕСКИМ КРИВЫМ! ЛУЧШЕ ВЗЯТЬ 2 или 3')
print(f'Получаем число k = {k}, 0 < k < q')

print('\nШаг 4. 	Вычислить точку эллиптической кривой C=kP и определить  r=x_C(mod q). Если r=0, то вернуться к шагу 3')
print(f'Считаем точку C = kP, у нас C = {k}P')
print('В базовом случае нужно посчитать: 2P = P + P, 3P = 2P + P, 4P = 2P + 2P, 7P = 4P + 3P')
print(f'У нас есть точка P = {P}, значение a = {a_el}, значение b = {b_el}')
x1 = P[0]
y1 = P[1]

print('\nСкладываем две одинаковых точки 2P = P + P, поэтому используем формулу 3 Эллиптической кривой')
print('57:55 на видео: https://my.mts-link.ru/19684723/2134589447/record-new/954249942 + скриншот в папке проекта 2P.PNG'
      'т.к. там получается дробь, то нужно использовать модуль: из числителя вычитаем модуль 103, получается -70, в итоге x3 = 19. '
      'Формулу привожу ниже на всякий случай, но нужны расчёты с применением модуля')

# Формула 3 эллиптической кривой для x3
# x3_chislitel: int = ((3*x1**2 + a)**2)
# x3_znamenatel: int = ((2*y1)**2)
# x3_final = (x3_chislitel / x3_znamenatel) - 2*x1
# print(f'Видим результат вычисления 2P: ({x3_chislitel} / {x3_znamenatel}) - {2*x1}')
# print(f'x3 = {x3_final}')

x3_2P_point = 19

# Формула 3 эллиптической кривой для y3
# print('\nНаходим y3')
# y3_chislitel: int = (3*x1**2 + a) % p
# y3_znamenatel: int = 2*y1 % p
# y3_first: int = (x1 - x3_2P_point)
# print(f'Данные для расчёта: ({y3_chislitel} / {y3_znamenatel}) * {x1 - x3_2P_point} - {y1}')

print('Результат для базового случая 73, это не очень удобно, поэтому от 73 отнимаем модуль 103, получаем -30')
y3_2P_point = -30

print(f'Точка 2P с координатами ({x3_2P_point}, {y3_2P_point})')
print('Проверку можно выполнить по исходной формуле эллиптической кривой: y**2 = x**3 + ax + b')
xx = (y3_2P_point**2) % p
yy = (x3_2P_point**3 + a_el*x3_2P_point + b_el) % p
print(f'({x3_2P_point}**3 + {a_el}*{x3_2P_point}  + {b_el}) % {p}')

if xx == yy:
      print('Проверка выполнена успешно, точка подходит')
else:
      print('Данные не сопадают!')
print(f'Значение 1 =  {xx}, Значение 2 =  {yy}')

print(f'\n\nСчитаем точку 3P = 2P + P, \n3P = ({x3_2P_point}, {y3_2P_point}) + ({P[0]}, {P[1]})')
print('Точки разные, используем первую формулу эллиптической кривой, детали базового расчёта на скриншоте 3P.PNG')

# Формула 1 эллиптической кривой для x3
# x3_3P_chislitel: int = ((P[1] - y3_2P_point)**2) % p
# x3_3P_znamenatel: int = ((P[0] - x3_2P_point)**2) % p
# print(f'Промежуточный результат: ({x3_3P_chislitel} / {x3_3P_znamenatel}) - {x3_2P_point} - {P[0]}')
# x3_3P_final = (x3_3P_chislitel // x3_3P_znamenatel) - (x3_2P_point - P[0])
# print(f'x3  =  {x3_3P_final}')

x3_3P_point = -42

# Формула 1 эллиптической кривой для y3
# y3_3P_chislitel: int = (P[1] - y3_2P_point)
# y3_3P_znamenatel: int = (P[0] - x3_2P_point)
# print(f'Промежуточный результат: ({y3_3P_chislitel} / {y3_3P_znamenatel}) * ({x3_2P_point} - {x3_3P_final}) - {y3_2P_point}')
# y3_3P_final = (y3_3P_chislitel // y3_3P_znamenatel) * (x3_2P_point - x3_3P_final) - y3_2P_point
# print(f'y3   =   {y3_3P_final}')

y3_3P_point = 37

print(f'Точка 3P с координатами ({x3_3P_point}, {y3_3P_point})')

print('ВНИМАНИЕ! Я остановил расчёт после нахождения 3P, в базовом примере ищут 7P, что является тратой времени на экзамене, поэтому лучше 3P')

print('\nОпределить  r=x(финальной искомой точки) (mod q). Если r=0, то вернуться к шагу 3')
r = x3_3P_point % p
print(f'r = {r}')

print('Шаг 5 	Вычислить значение s= (rd+ke) (mod q). Если s=0, то вернуться к шагу 3.')
print('Где d - ключ подписи, выбираем самостоятельно')
d = 32
s = (r*d + k*e) % p
print(f'Значение s = {s}')

print('\n\nВычислить двоичные векторы, соответствующие числам r и s, и определить цифровую подпись ζ= r || s как конкатенацию данных двоичных векторов.')
print('Переводим r и s в двоичные значения')
r_bin = bin(r)[2:]
s_bin = bin(s)[2:]
print(f'r двоичное = {r_bin}')
print(f's_двоичное = {s_bin}')
final_subscription = r_bin + s_bin
print(f'Электронная подпись {final_subscription}')
