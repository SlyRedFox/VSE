# Программная реализация ГОСТ 34.10-2012

import math


# Параметры схемы цифровой подписи
# 1
# Простое число p модуль эллиптической кривой
p: int = 101

# 2
# Эллиптическая кривая E, с параметрами a, b
# Имеет вид: E a,b(Fp)
a: int = 4
b: int = 1

# Вид нашей эллептической кривой
print(f'Вид нашей эллептической кривой: E{a},{b}(F{101})')


# Уравнение эллептической кривой в общем виде имеет следующий вид:
# у**2 = x**3 + ax + b
print(f'В нашем случае уравнение эллептической кривой имеет вид: у**2 = x**3 + {a}x + {b}')


# Проверяем условие гладкости кривой по формуле:
# (-4a**3 - 27b**2) mod p     НЕ должно быть не равно 0
res: int = ((-4*a**3) - (27*b**2)) % p
print(f'Проверяем условие гладкости эллептической кривой:')
if res != 0:
    print(f'Наше значение: {res}\nУсловие гладкости эллептической кривой выполнено.')
else:
    print(f'Наше значение: {res}\nYсловие гладкости эллептической кривой НЕ ВЫПОЛНЕНО!')


# 3
# Целое число m - порядок группы точек эллиптической кривой E, такое, чтобы выполнялось условие:
# p+1-2*math.sqrt(p) <= m <= p+1+2*math.sqrt(p)
print('\nНаходим порядок группы точек эллиптической кривой (округление в большую сторону), переменная m')
p1_number: int = math.ceil(round(p+1-2*math.sqrt(p)))
p2_number: int = math.ceil(round(p+1+2*math.sqrt(p)))
print(f'Порядок группы точек эллиптической кривой: {p1_number} <= m <= {p2_number}')

print('Найдём же m')

# TODO: ВСПОМНИТЬ ЭЛЛИПТИЧЕСКИЕ КРИВЫЕ!!!!!!!!!!!!!!!!!!!!!!! Без них не получится. У нас получилось m=112
m = 112

# 4
# найдём q - порядок циклической подргуппы группы точек эллиптической кривой
print('\nНайдём q. Точку, которая после семи сложений друг с другом даст нам в результате точку 0')
# q соответствует условию: m = n*q , где n - натуральное число. При этом q - простое число.
# Т. к. в нашем случае m = 112, то у нас получается ф-ла:
# 112 = n * q, т.е. 112 = 16 * 7
# 22:19 время!
q: int = 7

# 5
#  Мы должны найти точку, не являющейся точкой 0 эллиптической кривой, порядком которой является количество сложений q (7)
# Берём конкретную точку для примера: P = (4, 9)
x: int = 4
y: int = 9
# Убеждаемся, что она действительно принадлежит нашей эллиптической кривой: подставим её координаты в наше уравнение.
# Уравнение эллептической кривой в общем виде имеет следующий вид:
# у**2 = x**3 + ax + b
p_x: int = x**3 + a*x + b
print(f'Результат для точки эллиптической кривой: {p_x}')

# У нас получилось 81. В этом случае не нужно строить табицу квадратов, т. к. 81 - это таблица квадратов: +9 и -9, т.е.
# корень из 81 это +-9 , а значит уравнению нашей эллиптической кривой F101 данная точка удовлетворяет, т.к. у нас там
# значения от 1 до 50 и от -1 до -50.
# Мы убедились, что точка принадлежит кривой Е.

# Но этого недостаточно, нужно убедиться, что порядок данной точки равен 7. O(P) = 7!

# 6
# Хэш-функция.
# Прописана в ГОСТе.

# 7
# Указываем ключ подписи - целое число d
d_signature_key: int = 3

# 8
# Ключ проверки подписи, это точка эллиптической кривой Q = dP
# т.к. d (d_signature_key) = 3, то в нашем случае Q = dP = 3P, а чтобы найти 3P нужны расчёты.
# Точка P известна, поэтому нам нужно получить точку 2P, чтобы получить 3P
# есть точка P, равная (4, 9), значит, 2P = P + P, у нас для этого есть формулы расчёта эллиптической кривой.
# точки одинаковые, поэтому воспользуемся второй формулой расчёта точек эллиптической кривой
x1: int = 4
y1: int = 9

print('\nРасчёт x3 (формула два)')
x3_1: int = ((3*x1**2 + a)**2) % p
x3_2: int = ((2*y1)**2) % p
print(f'Видим результат вычисления 2P: {x3_1} / {x3_2} - {2*x1}')
# Результат будет (78 / 21) - 8
# Этот результат можно сократить на три, чтобы получилось (26 / 7) - 8, т.к. 26 не делится нацело на 7, то мы должны
# добавлять модуль (у нас это 101) в числитель до тех пор, пока не будет целочисленного деления
# Получается (329 / 7) - 8 = 39
# Далее расчёт программный:

# временный элемент для расчётов temp_elem_for_x3
temp_elem_for_x3: int = x3_1
for elem in range(1000):
    if (temp_elem_for_x3 % x3_2) == 0:
        print(f'{temp_elem_for_x3} Делится нацело, результат: {temp_elem_for_x3 % x3_2}')
        break
    else:
        # print(f'{temp_elem_for_x3} НЕ делится нацело. Прибавляем к числителю модуль {p}')
        temp_elem_for_x3 += p
print(f'Результат: число, которое делится на цело после прибавления к числителю модуля: {temp_elem_for_x3}')

x3_result: int = (temp_elem_for_x3 // x3_2) - 2*x1
print(f'Обновлённый результат вычисления 2P: {x3_result}')

print(f'Результат вычислений: x3 = {x3_result}')


print('\nРасчёт у3 (формула два)')
y3_1: int = (3*x1**2 + a) % p
y3_2: int = 2*y1 % p
y3_3: int = (x1 - x3_result)


print(f'Данные для расчёта: {y3_1} / {y3_2} * {x1 - x3_result} - {y1}')


# временный элемент для расчётов temp_elem_for_у3
for_raschet_y3: int = y3_1 * y3_3
for elem in range(1000):
    if (for_raschet_y3 % y3_2) == 0:
        print(f'{for_raschet_y3} Делится нацело, результат: {for_raschet_y3 % y3_2}')
        break
    else:
        # print(f'{for_raschet_y3} НЕ делится нацело. Прибавляем к числителю модуль {p}')
        for_raschet_y3 += p
print(f'Результат: число, которое делится на цело после прибавления к числителю модуля: {for_raschet_y3}')

y3_result: int = ((for_raschet_y3 // y3_2) - y1) % p
print(f'Результат вычислений: y3 = {y3_result}')

print(f'Итоговый результат для 2P: ({x3_result}, {y3_result})')

print(f'\n\nВычисляем 3P = 2P + P: 3P = ({x3_result}, {y3_result}) + ({x1}, {y1})')
# точки разные, воспользуемся первой формулой расчёта точек эллиптической кривой

print('\nРасчёт x3 (формула один)')
x1_formula_one: int = x3_result
y1_formula_one: int = y3_result

x2_formula_one: int = x1
y2_formula_one: int = y1
print(f'Подготовленные данные: x1 = {x1_formula_one}, y1 = {y1_formula_one}, x2 = {x2_formula_one}, y2 = {y2_formula_one}')


x3_formula_one: int = ((y2_formula_one - y1_formula_one)**2) % p
x3_2_formula_one: int = ((x2_formula_one - x1_formula_one)**2) % p
print(f'Промежуточный результат: {x3_formula_one} / {x3_2_formula_one} - {x1_formula_one} - {x2_formula_one}')


#TODO: временные расчёты добавить в функцию
# временный элемент для расчётов по формуле один, прибавляем модуль
x_temp_elem_formula_one: int = x3_formula_one
for elem in range(1000):
    if (x_temp_elem_formula_one % x3_2_formula_one) == 0:
        print(f'{x_temp_elem_formula_one} Делится нацело, результат: {x_temp_elem_formula_one % x3_2_formula_one}')
        break
    else:
        # print(f'{temp_elem_for_x3} НЕ делится нацело. Прибавляем к числителю модуль {p}')
        x_temp_elem_formula_one += p
print(f'Результат: число, которое делится на цело после прибавления к числителю модуля: {x_temp_elem_formula_one}')

x3_result_formula_one: int = (x_temp_elem_formula_one // x3_2_formula_one) - x1_formula_one - x2_formula_one
print(f'Результат для формулы 1, x3 = {x3_result_formula_one}')







print('\nРасчёт y3 (формула один)')
y3_formula_one: int = (y2_formula_one - y1_formula_one)
y3_2_formula_one: int = (x2_formula_one - x1_formula_one)
y3_3_formula_one: int = (x1_formula_one - x3_result_formula_one)


print(f'Данные для расчёта: {y3_formula_one} / {y3_2_formula_one} * {y3_3_formula_one} - {y1_formula_one}')

# временный элемент для расчётов y_temp_elem_formula_one
y_temp_elem_formula_one: int = y3_formula_one * y3_3_formula_one
for elem in range(1000):
    if (y_temp_elem_formula_one % y3_2_formula_one) == 0:
        print(f'{y_temp_elem_formula_one} Делится нацело, результат: {y_temp_elem_formula_one % y3_2_formula_one}')
        break
    else:
        # print(f'{for_raschet_y3} НЕ делится нацело. Прибавляем к числителю модуль {p}')
        y_temp_elem_formula_one += p
print(f'Результат: число, которое делится на цело после прибавления к числителю модуля: {y_temp_elem_formula_one}')

y3_result: int = ((y_temp_elem_formula_one // y3_2_formula_one) - y1_formula_one) % p
print(f'Результат вычислений: y3 = {y3_result}')
